<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .badge {
            display: inline-block;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #FFD700;
            color: #FFD700;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            text-shadow: 0 0 10px #FFD700;
        }

        .guide {
            color: #ccc;
            font-size: 13px;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px black;
        }

        button {
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000);
            color: #FFF;
            border: 2px solid #FFD700;
            padding: 15px 50px;
            border-radius: 30px;
            font-weight: 800;
            font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #camera-preview {
            position: fixed;
            top: 12px;
            right: 12px;

            width: 160px;
            height: 120px;

            border-radius: 8px;
            overflow: hidden;

            border: 2px solid rgba(0, 255, 0, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);

            transform: scaleX(-1);
            opacity: 1;

            z-index: 200;
            pointer-events: none;
            background: #000;
        }

        /* Responsive cho mobile màn hình dọc */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            #camera-preview {
                width: 120px;
                height: 90px;
                top: 8px;
                right: 8px;
                border-width: 1.5px;
            }
        }

        /* Responsive cho mobile rất nhỏ */
        @media screen and (max-width: 480px) and (orientation: portrait) {
            #camera-preview {
                width: 100px;
                height: 75px;
                top: 6px;
                right: 6px;
            }
        }


        #error-log {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            color: red;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            padding: 10px;
        }
    </style>
</head>

<body>
    <div id="error-log"></div>
    <div id="ui-layer">
        <button id="btnStart" onclick="startSystem()">Start</button>
    </div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        // ==========================================
        // 1. RESOURCES CONFIG
        // ==========================================
        const MUSIC_FILES = [
            './music/song1.mp3',
            './music/song2.mp3'
        ];
        
        let currentMusicIndex = 0;
        let bgMusic = null;
        let isChangingSong = false;
        
        function initMusic() {
            bgMusic = new Audio(MUSIC_FILES[currentMusicIndex]);
            bgMusic.loop = false;
            bgMusic.volume = 1.0;
            
            bgMusic.addEventListener('ended', () => {
                if (!isChangingSong) {
                    playNextSong();
                }
            });
        }
        
        function playNextSong() {
            if (isChangingSong) return;
            
            isChangingSong = true;
            currentMusicIndex = (currentMusicIndex + 1) % MUSIC_FILES.length;
            
            // Fade out bài cũ
            const fadeOutInterval = setInterval(() => {
                if (bgMusic && bgMusic.volume > 0) {
                    bgMusic.volume = Math.max(0, bgMusic.volume - 0.1);
                } else {
                    clearInterval(fadeOutInterval);
                    if (bgMusic) {
                        bgMusic.pause();
                        bgMusic.currentTime = 0;
                    }
                    
                    // Đợi 1 giây trước khi phát bài mới
                    setTimeout(() => {
                        bgMusic = new Audio(MUSIC_FILES[currentMusicIndex]);
                        bgMusic.loop = false;
                        bgMusic.volume = 0;
                        
                        bgMusic.addEventListener('ended', () => {
                            if (!isChangingSong) {
                                playNextSong();
                            }
                        });
                        
                        bgMusic.play().catch(e => console.log(e));
                        
                        // Fade in bài mới
                        const fadeInInterval = setInterval(() => {
                            if (bgMusic && bgMusic.volume < 1.0) {
                                bgMusic.volume = Math.min(1.0, bgMusic.volume + 0.1);
                            } else {
                                clearInterval(fadeInInterval);
                                isChangingSong = false;
                            }
                        }, 50);
                    }, 1000);
                }
            }, 100);
        }
        
        // Xử lý double click để đổi bài
        let lastClickTime = 0;
        document.addEventListener('dblclick', (e) => {
            e.preventDefault();
            playNextSong();
        });

        const loader = new THREE.TextureLoader();
        const photoFiles = ['./img/a1.jpg', './img/a2.jpg', './img/a3.jpg', './img/a4.jpg']; //Thay hoặc thêm số ảnh dòng 319 sửa ở đây và folder img
        const photoTextures = [];
        photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

        function createCustomTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64, cy = 64;

            if (type === 'gold_glow') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
                grd.addColorStop(0, '#FFFFFF');
                grd.addColorStop(0.2, '#FFFFE0');
                grd.addColorStop(0.5, '#FFD700');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);

            } else if (type === 'red_light') {
                const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
                grd.addColorStop(0, '#FFAAAA');
                grd.addColorStop(0.3, '#FF0000');
                grd.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grd; ctx.fillRect(0, 0, 128, 128);

            } else if (type === 'gift_red') {
                ctx.fillStyle = '#D32F2F'; 
                ctx.fillRect(20, 20, 88, 88);
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(54, 20, 20, 88);
                ctx.fillRect(20, 54, 88, 20);
                ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 2; ctx.strokeRect(20, 20, 88, 88);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const textures = {
            gold: createCustomTexture('gold_glow'),
            red: createCustomTexture('red_light'),
            gift: createCustomTexture('gift_red')
        };

        // ==========================================
        // 2. SYSTEM CONFIG
        // ==========================================
        const CONFIG = {
            goldCount: 2000,  
            redCount: 300,  
            giftCount: 150, 
            explodeRadius: 65,
            photoOrbitRadius: 25,
            treeHeight: 70,
            treeBaseRadius: 35,
            heartSize: 40 
        };

        let scene, camera, renderer;
        let groupGold, groupRed, groupGift; 
        let photoMeshes = [];
        let titleMesh, starMesh, testTextMesh;
        let textPoints = []; // Lưu các điểm từ text
        let isShowingText = false; // Flag để phân biệt xòe tay vs giơ 3 ngón

        let state = 'TREE';
        let selectedIndex = 0;
        let handX = 0.5;
        let heartRotation = 0;

        
        // ==========================================
        // 3. TEXT TO POINTS
        // ==========================================
        function generateTextPoints() {
            const canvas = document.createElement('canvas');
            const isMobilePortrait = window.innerWidth <= 768 && window.innerHeight > window.innerWidth;
            
            if (isMobilePortrait) {
                // Mobile màn hình dọc: 5 dòng
                canvas.width = 2048;
                canvas.height = 2048;
                const ctx = canvas.getContext('2d');
                
                // Vẽ nền đen
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Vẽ text màu trắng
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 200px "Arial", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 5 dòng cho mobile
                const lineHeight = 350;
                const startY = canvas.height / 2 - (lineHeight * 2);
                
                ctx.fillText('Merry', canvas.width / 2, startY);
                ctx.fillText('Christmas', canvas.width / 2, startY + lineHeight);
                ctx.fillText('Enspire', canvas.width / 2, startY + lineHeight * 2);
                
                // Đọc pixel và tạo điểm
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const points = [];
                const step = 3;
                
                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        const index = (y * canvas.width + x) * 4;
                        const r = imageData.data[index];
                        const g = imageData.data[index + 1];
                        const b = imageData.data[index + 2];
                        
                        if (r > 0 || g > 0 || b > 0) {
                            const x3d = (x / canvas.width - 0.5) * 100;
                            const y3d = (0.5 - y / canvas.height) * 80;
                            const z3d = 0;
                            points.push(x3d, y3d, z3d);
                        }
                    }
                }
                
                return points;
            } else {
                // Desktop: 2 dòng như cũ
                canvas.width = 3072;
                canvas.height = 1536;
                const ctx = canvas.getContext('2d');
                
                // Vẽ nền đen
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Vẽ text màu trắng - tăng font size
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 280px "Arial", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Dòng 1: "Marry Christmas"
                ctx.fillText('Marry Christmas', canvas.width / 2, canvas.height / 2 - 150);
                
                // Dòng 2: "Enspire"
                ctx.fillText('Enspire', canvas.width / 2, canvas.height / 2 + 150);
                
                // Đọc pixel và tạo điểm
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const points = [];
                const step = 3;
                
                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        const index = (y * canvas.width + x) * 4;
                        const r = imageData.data[index];
                        const g = imageData.data[index + 1];
                        const b = imageData.data[index + 2];
                        
                        if (r > 0 || g > 0 || b > 0) {
                            const x3d = (x / canvas.width - 0.5) * 120;
                            const y3d = (0.5 - y / canvas.height) * 60;
                            const z3d = 0;
                            points.push(x3d, y3d, z3d);
                        }
                    }
                }
                
                return points;
            }
        }

        // ==========================================
        // 3. THREE.JS SYSTEM
        // ==========================================
        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticleSystem('red', CONFIG.redCount, 3.5); 
            groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0); 

            createPhotos();
            createDecorations();
            animate();
        }

        function createParticleSystem(type, count, size) {
            const pPositions = [];
            const pExplodeTargets = [];
            const pTreeTargets = [];
            const pHeartTargets = [];

            // Tạo text points nếu chưa có
            if (textPoints.length === 0) {
                textPoints = generateTextPoints();
            }

            for (let i = 0; i < count; i++) {
                
                const h = Math.random() * CONFIG.treeHeight;
                const y = h - CONFIG.treeHeight / 2;

                
                let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random() * 0.1;

                const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
                const r = maxR * radiusRatio;
                const theta = Math.random() * Math.PI * 2;

                const tx = r * Math.cos(theta);
                const tz = r * Math.sin(theta);
                pTreeTargets.push(tx, y, tz);

                // Tạo cả 2 loại explode targets: random sphere (mặc định) và text points
                // Random sphere cho xòe tay
                const u = Math.random();
                const v = Math.random();
                const phi = Math.acos(2 * v - 1);
                const lam = 2 * Math.PI * u;
                let radMult = (type === 'gift') ? 1.2 : 1.0;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
                const ex = rad * Math.sin(phi) * Math.cos(lam);
                const ey = rad * Math.sin(phi) * Math.sin(lam);
                const ez = rad * Math.cos(phi);
                pExplodeTargets.push(ex, ey, ez);

                // --- Heart shape ---
                const t = Math.random() * Math.PI * 2;
                const s = CONFIG.heartSize;
                let hx = s * 16 * Math.pow(Math.sin(t), 3) / 16;
                let hy = s * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 16;
                let hz = (Math.random() - 0.5) * 15;
                pHeartTargets.push(hx, hy, hz);

                
                pPositions.push(tx, y, tz);
            }

            // Tạo text explode targets từ text points
            const pTextExplodeTargets = [];
            if (textPoints.length > 0) {
                for (let i = 0; i < count; i++) {
                    const pointIndex = Math.floor(Math.random() * (textPoints.length / 3)) * 3;
                    const ex = textPoints[pointIndex] || 0;
                    const ey = textPoints[pointIndex + 1] || 0;
                    const ez = textPoints[pointIndex + 2] || 0;
                    pTextExplodeTargets.push(ex, ey, ez);
                }
            } else {
                // Fallback: dùng random nếu chưa có text points
                pTextExplodeTargets.push(...pExplodeTargets);
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
            geo.userData = { tree: pTreeTargets, explode: pExplodeTargets, explodeText: pTextExplodeTargets, heart: pHeartTargets };

            const mat = new THREE.PointsMaterial({
                size: size,
                map: textures[type],
                transparent: true, opacity: 1.0,
                
                blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            const borderGeo = new THREE.PlaneGeometry(9, 9);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });

            for (let i = 0; i < 7; i++) { //số ảnh hiển thị 4
                const mat = new THREE.MeshBasicMaterial({
                    map: photoTextures[i], side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1;
                mesh.add(border);

                mesh.visible = false;
                mesh.scale.set(0, 0, 0);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            // ===============================
            // ❤️ I LOVE YOU (INSIDE HEART)
            // ===============================
            const loveCanvas = document.createElement('canvas');
            loveCanvas.width = 1024;
            loveCanvas.height = 256;
            const lctx = loveCanvas.getContext('2d');

            lctx.clearRect(0, 0, 1024, 256);
            lctx.font = 'bold italic 120px "Times New Roman"';
            lctx.textAlign = 'center';
            lctx.fillStyle = '#FF3366';
            lctx.shadowColor = '#FF99AA';
            lctx.shadowBlur = 40;
            lctx.fillText('I LOVE YOU', 512, 160);

            const loveTex = new THREE.CanvasTexture(loveCanvas);
            const loveMat = new THREE.MeshBasicMaterial({
                map: loveTex,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            loveTextMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(40, 10),
                loveMat
            );

            loveTextMesh.position.set(0, 0, 0);
            loveTextMesh.visible = false;
            scene.add(loveTextMesh);

            
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold italic 90px "Times New Roman"';
            ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
            ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 40;
            ctx.fillText("MERRY CHRISTMAS", 512, 130);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
            titleMesh.position.set(0, 50, 0);
            scene.add(titleMesh);

            
            const starCanvas = document.createElement('canvas');
            starCanvas.width = 128; starCanvas.height = 128;
            const sCtx = starCanvas.getContext('2d');
            sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor = "#FFF"; sCtx.shadowBlur = 20;
            sCtx.beginPath();
            const cx = 64, cy = 64, outer = 50, inner = 20;
            for (let i = 0; i < 5; i++) {
                sCtx.lineTo(cx + Math.cos((18 + i * 72) / 180 * Math.PI) * outer, cy - Math.sin((18 + i * 72) / 180 * Math.PI) * outer);
                sCtx.lineTo(cx + Math.cos((54 + i * 72) / 180 * Math.PI) * inner, cy - Math.sin((54 + i * 72) / 180 * Math.PI) * inner);
            }
            sCtx.closePath(); sCtx.fill();
            const starTex = new THREE.CanvasTexture(starCanvas);
            const starMat = new THREE.MeshBasicMaterial({ map: starTex, transparent: true, blending: THREE.AdditiveBlending });
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
            starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
            scene.add(starMesh);

            // ===============================
            // TEST TEXT 3D
            // ===============================
            const testCanvas = document.createElement('canvas');
            testCanvas.width = 2048;
            testCanvas.height = 512;
            const testCtx = testCanvas.getContext('2d');
            testCtx.clearRect(0, 0, 2048, 512);
            testCtx.font = 'bold 180px "Arial", sans-serif';
            testCtx.textAlign = 'center';
            testCtx.fillStyle = '#FFD700';
            testCtx.shadowColor = '#FFA500';
            testCtx.shadowBlur = 50;
            testCtx.fillText('Merry Christmas bạn Thư thân mến', 1024, 280);

            const testTex = new THREE.CanvasTexture(testCanvas);
            const testMat = new THREE.MeshBasicMaterial({
                map: testTex,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                side: THREE.DoubleSide
            });

            testTextMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(60, 15),
                testMat
            );

            testTextMesh.position.set(0, 0, 0);
            testTextMesh.visible = false;
            scene.add(testTextMesh);
        }

        function updateParticleGroup(group, targetState, speed, handRotY, time, isBlinking) {
            const positions = group.geometry.attributes.position.array;
            let targetKey = 'tree';
            if (targetState === 'EXPLODE') {
                // Nếu đang hiển thị chữ (giơ 3 ngón) thì dùng explodeText, nếu không thì dùng explode (random)
                targetKey = isShowingText ? 'explodeText' : 'explode';
            } else if (targetState === 'PHOTO') targetKey = 'explode';
            else if (targetState === 'HEART') targetKey = 'heart';

            const targets = group.geometry.userData[targetKey];

            for (let i = 0; i < positions.length; i++) {
                positions[i] += (targets[i] - positions[i]) * speed;
            }
            group.geometry.attributes.position.needsUpdate = true;

            
            if (targetState === 'TREE') {
                group.rotation.y += 0.003;
                
                if (isBlinking) {
                    
                    
                    const scale = 1 + Math.sin(time * 5) * 0.2;
                    group.scale.set(scale, scale, scale);
                } else {
                    group.scale.set(1, 1, 1);
                }
            } else if (targetState === 'HEART') {
                group.scale.set(1, 1, 1);
                group.rotation.y = heartRotation;
            } else if (targetState === 'EXPLODE') {
                // Xoay 3D dựa trên vị trí tay (handX) khi ở trạng thái EXPLODE
                group.scale.set(1, 1, 1);
                group.rotation.y += (handRotY - group.rotation.y) * 0.05;
            } else {
                group.scale.set(1, 1, 1);
                group.rotation.y += (handRotY - group.rotation.y) * 0.05;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const speed = 0.06;
            const handRotY = (handX - 0.5) * 2.5;

            
            updateParticleGroup(groupGold, state, speed, handRotY, time, false);
            updateParticleGroup(groupRed, state, speed, handRotY, time, false); 
            updateParticleGroup(groupGift, state, speed, handRotY, time, false);

            // Quay trái tim
            if (state === 'HEART') {
                heartRotation += 0.01;
                // ❤️ Ẩn chữ I LOVE YOU trong tim
                if (loveTextMesh) loveTextMesh.visible = false;
            }

            
            photoMeshes.forEach((mesh, i) => {
                if (!mesh.material.map && photoTextures[i]) {
                    mesh.material.map = photoTextures[i]; mesh.material.needsUpdate = true;
                }
            });

            if (state === 'TREE') {
                if (loveTextMesh) loveTextMesh.visible = false;
                if (testTextMesh) testTextMesh.visible = false;

                titleMesh.visible = false; starMesh.visible = true;
                starMesh.rotation.z -= 0.02;
                photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); m.visible = false; });

            } else if (state === 'HEART') {
                titleMesh.visible = false; starMesh.visible = false;
                if (testTextMesh) testTextMesh.visible = false;
                photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); m.visible = false; });

            } else if (state === 'EXPLODE') {
                titleMesh.visible = false; starMesh.visible = false;
                
                // Ẩn tất cả ảnh và text mesh
                photoMeshes.forEach(m => { 
                    m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); 
                    m.visible = false; 
                });
                if (testTextMesh) testTextMesh.visible = false;
                
                // Particles sẽ tự động sắp xếp thành chữ thông qua pExplodeTargets

            } else if (state === 'PHOTO') {
                // Khi dấu OK, chuyển sang HEART (không có I LOVE YOU)
                state = 'HEART';
                // Ẩn text và ảnh
                if (testTextMesh) testTextMesh.visible = false;
                photoMeshes.forEach(m => { 
                    m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); 
                    m.visible = false; 
                });
            }

            renderer.render(scene, camera);
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            initMusic();
            if (bgMusic) {
                bgMusic.play().catch(e => console.log(e));
            }
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            canvas.width = 160;
            canvas.height = 120;
            const ctx = canvas.getContext('2d');

            let frameCnt = 0;
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults(results => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

                if (results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x;
                    
                    // Vẽ các vector và landmarks
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = '#00FF00';
                    
                    // Vẽ các điểm landmark
                    for (let i = 0; i < lm.length; i++) {
                        const x = lm[i].x * canvas.width;
                        const y = lm[i].y * canvas.height;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Vẽ các đường nối quan trọng
                    ctx.strokeStyle = '#FF00FF';
                    ctx.lineWidth = 1;
                    
                    // Ngón trỏ
                    if (lm[8] && lm[6]) {
                        ctx.beginPath();
                        ctx.moveTo(lm[8].x * canvas.width, lm[8].y * canvas.height);
                        ctx.lineTo(lm[6].x * canvas.width, lm[6].y * canvas.height);
                        ctx.stroke();
                    }
                    
                    // Ngón giữa
                    if (lm[12] && lm[10]) {
                        ctx.beginPath();
                        ctx.moveTo(lm[12].x * canvas.width, lm[12].y * canvas.height);
                        ctx.lineTo(lm[10].x * canvas.width, lm[10].y * canvas.height);
                        ctx.stroke();
                    }
                    
                    // Ngón áp út
                    if (lm[16] && lm[14]) {
                        ctx.beginPath();
                        ctx.moveTo(lm[16].x * canvas.width, lm[16].y * canvas.height);
                        ctx.lineTo(lm[14].x * canvas.width, lm[14].y * canvas.height);
                        ctx.stroke();
                    }
                    
                    // Ngón út
                    if (lm[20] && lm[18]) {
                        ctx.beginPath();
                        ctx.moveTo(lm[20].x * canvas.width, lm[20].y * canvas.height);
                        ctx.lineTo(lm[18].x * canvas.width, lm[18].y * canvas.height);
                        ctx.stroke();
                    }
                    
                    // Ngón cái
                    if (lm[4] && lm[3]) {
                        ctx.beginPath();
                        ctx.moveTo(lm[4].x * canvas.width, lm[4].y * canvas.height);
                        ctx.lineTo(lm[3].x * canvas.width, lm[3].y * canvas.height);
                        ctx.stroke();
                    }
                    
                    // Vẽ vector từ cổ tay đến các ngón
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 1;
                    const wrist = lm[0];
                    const tips = [4, 8, 12, 16, 20];
                    tips.forEach(tipIndex => {
                        if (lm[tipIndex]) {
                            ctx.beginPath();
                            ctx.moveTo(wrist.x * canvas.width, wrist.y * canvas.height);
                            ctx.lineTo(lm[tipIndex].x * canvas.width, lm[tipIndex].y * canvas.height);
                            ctx.stroke();
                        }
                    });

                    // Lấy các điểm landmark
                    const indexTip = lm[8];      // Đầu ngón trỏ
                    const middleTip = lm[12];    // Đầu ngón giữa
                    const ringTip = lm[16];      // Đầu ngón áp út
                    const pinkyTip = lm[20];     // Đầu ngón út
                    const thumbTip = lm[4];       // Đầu ngón cái
                    
                    const indexPIP = lm[6];       // Khớp PIP ngón trỏ
                    const middlePIP = lm[10];     // Khớp PIP ngón giữa
                    const ringPIP = lm[14];      // Khớp PIP ngón áp út
                    const pinkyPIP = lm[18];      // Khớp PIP ngón út
                    const thumbIP = lm[3];        // Khớp IP ngón cái
                    
                    // Kiểm tra các ngón duỗi (tip cao hơn PIP/IP)
                    const indexExtended = indexTip.y < indexPIP.y;
                    const middleExtended = middleTip.y < middlePIP.y;
                    const ringExtended = ringTip.y < ringPIP.y;
                    const pinkyExtended = pinkyTip.y < pinkyPIP.y;
                    const thumbExtended = thumbTip.y < thumbIP.y;
                    
                    // Đếm số ngón duỗi (không tính ngón cái)
                    let extendedCount = 0;
                    if (indexExtended) extendedCount++;
                    if (middleExtended) extendedCount++;
                    if (ringExtended) extendedCount++;
                    if (pinkyExtended) extendedCount++;
                    
                    // Kiểm tra xòe cả 5 ngón (bao gồm ngón cái)
                    const allFiveFingersExtended = indexExtended && middleExtended && ringExtended && pinkyExtended && thumbExtended;
                    
                    // Logic điều khiển mới
                    if (allFiveFingersExtended) {
                        // Xòe cả 5 ngón → Mở cây thông (particles random)
                        isShowingText = false;
                        state = 'EXPLODE';
                    } else if (extendedCount === 2 && indexExtended && middleExtended) {
                        // Giơ 2 ngón (trỏ + giữa) → Hiển thị chữ
                        isShowingText = true;
                        state = 'EXPLODE';
                    } else if (extendedCount === 3 && indexExtended && middleExtended && ringExtended) {
                        // Giơ 3 ngón (trỏ + giữa + áp út) → Trái tim
                        isShowingText = false;
                        state = 'HEART';
                    } else {
                        // Còn lại: Đóng cây thông
                        isShowingText = false;
                        state = 'TREE';
                    }
                } else {
                    state = 'TREE';
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => {
                    frameCnt++; if (frameCnt % 3 !== 0) return;
                    await hands.send({ image: video });
                }, width: 320, height: 240
            });
            cameraUtils.start();
        }

        window.addEventListener('resize', () => {
            if (camera) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
            // Regenerate text points khi thay đổi kích thước màn hình
            textPoints = [];
        });
        function logError(e) { document.getElementById('error-log').style.display = 'block'; document.getElementById('error-log').innerText += e + "\n"; }
    </script>
</body>

</html>